---
title: "Trading Strategy: TMA in Metal Commodities Markets"
subtitle: "CA01 - Investment Fundamentals, Group Project"
author: "Group 8 - Benedikt Jaletzke, Stanislas Markov, Mark Negodyuk, Kateryna Tarasova, Olivia Zhang, Tom Tian"
date: "12/10/2020"
abstract: "Triangular Moving Averages in Metal Commodities Markets for Consistent Long/Short Returns"
output: html_document
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Official Checklist:
- Introduction
- Economic Rationale
- Data (Sources)
- Method Used
  - Technical Indicator
  - Market
- Main Findings
- Future Potential Analyses
  - Metal Cmpanies in Combination with SUE Earnings
  - Mixing in Other Asset Classes (Agriculture, Energy etc.)
- Appendix 


# See how the portfolio would do with S&P instead of Industrial Metals
# Or Agriculture
# Do that once ALL the calculations are finished. That way it should be a copy/paste job with fresh data. 



# Introduction

The idea for this group project was to come up with a strategy that either expoited an arbitrage opportunity in the market, or represents another form of hedge fund strategy. Our group decided to focus on using technical indicators. Within this area, we specifically chose moving averages, and as a suitable market for their application settled on metal commodities.

# Economic Rationale

# Data
## Papers
- [S&P GSCI Precious Metals Index](https://www.spglobal.com/spdji/en/indices/commodities/sp-gsci-precious-metals/#overview)
- [S&P GSCI Industrial Metals Index](https://www.spglobal.com/spdji/en/indices/commodities/sp-gsci-industrial-metals/#overview)

# Method Used

## Portfolio Allocation

In order to ideally work within the metals markets, the portfolio will consist ocmpletely of two already existing indices that are calculated on a daily basis, the S&P Precious Metals Index, consisting of [TBC] and the S&P Industrial Metals, containing [TBC]. By using these two indices as our baseline instead of attempting to construct our own, we can create a two-security portfolio with different weights to find the best possible results. As for the choice of allocations, we tried different combination weights of the indices. 

To construct the efficient portfolio, we had to calculate the return and variance of the two separate indices.

```{r}
# Return - Variance Calculation
# Combining both indices into one frame, cleaning it up a little
combined_indices <- full_join(industrial_1, precious_1, by = "date") %>% 
  rename(precious_metals = index.y,
         pm_close = close.y,
         ind_close = close.x,
         industrial_metals = index.x) %>% 
  subset(select = -c(ticker.x, ticker.y)) %>%
  head(-2)
  
#return and std
ind_price <- na.approx(zoo(combined_indices$ind_close, combined_indices$date))
prec_price <- na.approx(zoo(combined_indices$pm_close, combined_indices$date))

rets_industry <- Return.calculate(xts(ind_price),  method = "discrete")
names(rets_industry) <- "return_ind"
rets_prec <- Return.calculate(xts(prec_price),  method = "discrete")
names(rets_prec) <- "return_prec"

combined_indices <- cbind(combined_indices, rets_industry, rets_prec)

stats <- combined_indices %>% 
  summarise(mean_ind = mean(return_ind[-1]), mean_prec = mean(return_prec[-1]),
            sd_ind = sd(return_ind[-1]), sd_prec = sd(return_prec[-1]))
```

```{r}
# 50/50 Portfolio
# Weights
eq_w_pm <- 0.5
eq_w_ind <- 1-eq_w_pm

# calculate index
eq_w_ind <- combined_indices %>% 
  mutate(eq_weight = eq_w_pm * precious_metals + eq_w_ind * industrial_metals) %>% 
  subset(select = c(date, eq_weight))

# combine to larger dataframe
indices_equal <- right_join(eq_w_ind, combined_indices, by = "date") %>% 
 subset(select = -c(ind_close, pm_close )) %>% 
  subset(select = -c(return_ind, return_prec))

```


```{r}
# Efficient Portfolio
stats <- combined_indices %>% 
  summarise(mean_ind = mean(return_ind[-1]), mean_prec = mean(return_prec[-1]),
            sd_ind = sd(return_ind[-1]), sd_prec = sd(return_prec[-1]),
            corr_ind = cor(return_ind[-1],return_prec[-1]))

sh_r_max <- function(x){
  (x*stats$mean_ind+(1-x)*stats$mean_prec)/sqrt(x^2*stats$sd_ind^2+(1-x)^2*stats$sd_prec^2+2*x*(1-x)*stats$sd_ind*stats$sd_prec*stats$corr_ind)
}
# calcukating optimal weights for industrial index
opt_port <- optimize(f = sh_r_max, lower = -1,upper = 1, maximum = TRUE)

# assigning weights to the two indices
weight_industrial <- opt_port$objective
weight_precious <- 1-weight_industrial

# creating efficient(theoretically) index
efficient_index <- combined_indices %>% 
  mutate(efficient = weight_industrial * industrial_metals + weight_precious * precious_metals) %>% 
  subset(select = c(date, efficient))

# combining the four portfolios into one
portfolios <- left_join(indices_equal, efficient_index, by = "date") %>% 
  gather(index, values, eq_weight:efficient)

```

### Portfolio Statistics 
```{r}
# statistics (try) - STANISLAV!!! (AKA: Please Help on this!) We should create summary stats for the 4 portolios here to display in the output
stats_portfolio <- portfolios %>% 
  summarise(mean_ind = mean(return_ind[-1]), mean_prec = mean(return_prec[-1]),
            sd_ind = sd(return_ind[-1]), sd_prec = sd(return_prec[-1]),
            corr_ind = cor(return_ind[-1],return_prec[-1]))
```

```{r, fig.width = 11, echo=FALSE}
# Combination Graph
ggplot() + 
  geom_line(data = portfolios, aes(x=date, y=values, color = index)) + 
  scale_color_brewer(palette = "Spectral") + 
  theme_minimal() + 
  labs(title = "Price Development of the Different Combinations of Metals Indices",
       caption = "Source: Finaeon, S&P as of October 2020",
       x = "Date",
       y="Index (100=1/1/1990") +
  scale_color_discrete(name = "Series", labels = c("Efficient Portfolio", "Equal Weights", "Industrial Metals", "Precious Metals"))
```

The graph shows clearly that the most efficient portfolio is one in which the heaviest weighting is placed on the precious metals component of the portfolio, which is not surprising given it's outperformance of the industrial metals class, especially over the last ten years. For a further analysis, this raises the obvious question of whether a more efficient portfolio could be constructed using different indices/components that would diversify the returns away from this sector. 


## Technical Indicator

From https://uc-r.github.io/ts_moving_averages

The concept of simple moving averages can be extended to taking moving averages of moving averages. This technique is often employed with an even number of data points so that the final product is symmetric around each point. 
An even-numbered moving average is unbalanced, and for our purposes, the unbalancing will be in favor of more recent observations. For example, to calculate a 4-MA, the equation is as follows:
^yt=(ytâˆ’1+yt+yt+1+yt+2)/4

To make the moving average symmetric (and therefore more accurate), we then take a 2-MA of the 4-MA to create a 2 x 4-MA. For the 2-MA step, we average the current and previous moving averages, thus resulting in an overall estimate of:



### Finding appropriate Modifiers for the TMA

The main challenge lies in finding the appropriate time periods for the TMA. As it is an average of averages, we have to consider which of these will give us the best return. 
The best TMA will be one that fits the trend well enough, but can still react to changes in the underlying assets quickly enough to be useful.

To compute a basic TMA, we can use the ma() function and take a look at the output, in this case with a 30 day compound.
```{r, fig.width = 10}
# rolling averages. Useful for later calculations
# k = number of days used in average

portfolios_tma <- portfolios %>% 
  mutate(ma4 = ma(values, order = 30, centre = TRUE))

pf_subset <- portfolios_tma %>% 
  #filter(index == "eq_weight" || index == "efficient")
  filter(index %in% c("eq_weight", "efficient"))

unique(pf_subset$index)

# 30 Day TMAs over the daily data for the two composite portfolios
ggplot(pf_subset) +
  geom_line(aes(x = date, y=values, group = index), 
            #linetype = "twodash", 
            alpha = 0.8, fill = "black", size = 0.2) +
  geom_line(aes(x = date, y=ma4, color = index)) + 
  scale_y_log10() +
  scale_color_discrete(name = "Series", labels = c("Efficient Portfolio", "Equal Weights")) + 
  scale_color_brewer(palette="Dark2")

```

In order to see the efficiency of any portfolio, we have to implement buy and sell signals. In our case, as described earlier, the idea would be to buy when the TMA is passed upwards, and to sell & short when the line crosses below. 

This would give us a return of [TBA]

Using the optimize function we employed to get the portfolio weights earlier, we can attempt to maximise the output of our TMA line on both portfolios. 

## Market Choice
```{r, fig.width = 5}
combined_indices %>% 
  subset(select = c(precious_metals, industrial_metals)) %>% 
  ggpairs(combined_indices)
```

As the above corelation graph shows, and intuition would confirm, there is an extreme correlation between the different classes of metals. This is despite hte fact that gold, which makes up a large part of the precious metals index, is traded less for its value sas a metal from an utilitarian perspective and more because of it's economic value as a criiss/hedging asset. 

# Results / Main Findings

# Appendix
## Libraries
```{r}
library(lubridate)
library(tidyverse)
library(GGally)
library(skimr)
library(lubridate)
library(fpp2) 
library(zoo)
library(PerformanceAnalytics)
```


## Importing Indices - Metals
```{r}
# Data from Finaeon
# I would love to implement the GFD API in order to automatically pull this data in from their site. Maybe if I can get this done before Monday night I'll add it in. Would be cool to do this. 
precious_base <- read.csv("data/sp_precmet.csv", skip = 2)
industrial_base <- read.csv("data/sp_indmet.csv", skip = 2)

copper_base <- read.csv("data/separate metals/copper.csv", skip = 2)

clean_data <-  function(x){
  y <- lazy(x)
  y %>%
  mutate(date = as.Date(y$Date, format = "%m/%d/%Y")) %>% 
  filter(date > as.Date("1989-12-31")) %>% 
  subset(data = y, select = -c(Date, Open, High, Low)) %>% 
  rename(close = Close, 
         ticker = Ticker) %>% 
  mutate(index = close/close[1])
}

clean_data(copper)

equities <- import_gfd("data/equities_indices.csv")

# S&P Precious Metals Index
precious_1 <- precious_base %>%
  mutate(date = as.Date(precious_base$Date, format = "%m/%d/%Y")) %>% 
  filter(date > as.Date("1989-12-31")) %>% 
  subset(data = precious_base, select = -c(Date, Open, High, Low)) %>% 
  rename(close = Close, 
         ticker = Ticker) %>% 
  mutate(index = close/close[1])

# S&P Industrial Metals Index
industrial_1 <- industrial %>%
  mutate(date = as.Date(industrial_base$Date, format = "%m/%d/%Y")) %>% 
  filter(date > as.Date("1989-12-31")) %>% 
  subset(data = industrial_base, select = -c(Date, Open, High, Low)) %>% 
  rename(close = Close, 
         ticker = Ticker) %>% 
  mutate(index = close/close[1])

# Combining both indices into one frame, cleaning it up a little
combined_indices <- full_join(industrial_1, precious_1, by = "date") %>% 
  rename(precious_metals = index.y,
         pm_close = close.y,
         ind_close = close.x,
         industrial_metals = index.x) %>% 
  subset(select = -c(ticker.x, ticker.y))

# Simple Plot
ggplot() + 
  geom_line(data = combined_indices, aes(x=date, y=precious_metals), color = "red") + 
  geom_line(data = combined_indices, aes(x=date, y=industrial_metals), color = "green")
```

## Importing and Filtering Equities Indices for Comparison Purposes
```{r}
# Importing Index Data
# Filtering: Dates, Unused Indices (keeping )
global_equities_indices <- read.csv("data/global.csv", skip = 51)

gei_filtered <- global_equities_indices %>%
  mutate(date = as.Date(global_equities_indices$Date, format = "%Y/%m/%d")) %>% 
  filter(date > as.Date("1989-12-31")) %>% 
  subset(data = global_equities_indices, select = c(Date, X_NDXD_Close, X_DJA3D_Close, X_GDAXIPD_Close, X_SPXD_Close))
```
