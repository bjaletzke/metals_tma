---
title: "Trading Strategy: TMA in Metal Commodities Markets"
subtitle: "CA01 - Investment Fundamentals, Group Project"
author: "Group 8 - Benedikt Jaletzke, Stanislas Markov, Mark Negodyuk, Kateryna Tarasova, Olivia Zhang, Tom Tian"
date: "12/10/2020"
abstract: "Triangular Moving Averages in Metal Commodities Markets for Consistent Long/Short Returns"
output: html_document
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
## Libraries
```{r, echo = FALSE}
library(lubridate)
library(tidyverse)
library(GGally)
library(skimr)
library(lubridate)
library(fpp2) 
library(zoo)
library(PerformanceAnalytics)
library(reshape2)
```

# Official Checklist:
- Introduction
- Economic Rationale
- Data (Sources)
- Method Used
  - Technical Indicator
  - Market
- Main Findings
- Future Potential Analyses
  - Metal Cmpanies in Combination with SUE Earnings
  - Mixing in Other Asset Classes (Agriculture, Energy etc.)
- Appendix 

#### NOTES
#### See how the portfolio would do with S&P instead of Industrial Metals
#### Or Agriculture
#### Do that once ALL the calculations are finished. That way it should be a copy/paste job with fresh data. 
####

# Data Import 
```{r}
# Data Import and Cleaning
import_data <-  function(source){
  x <- read.csv(source, skip = 2)
  x %>%
  mutate(date = as.Date(x$Date, format = "%m/%d/%Y")) %>% 
  filter(date > as.Date("1989-12-31")) %>% 
  subset(data = x, select = -c(Date, Open, High, Low)) %>% 
  rename(close = Close, 
         ticker = Ticker) %>% 
  mutate(index = close/close[1])
}

# I would love to implement the GFD API in order to automatically pull this data in from their site. Maybe if I can get this done before Monday night I'll add it in. Would be cool to do this. 
precious_1 <- import_data("data/sp_precmet.csv")
industrial_1 <- import_data("data/sp_indmet.csv")

# Combining both indices into one frame, cleaning it up a little
combined_indices <- full_join(industrial_1, precious_1, by = "date") %>% 
  rename(precious_metals = index.y,
         pm_close = close.y,
         ind_close = close.x,
         industrial_metals = index.x) %>% 
  subset(select = -c(ticker.x, ticker.y)) %>%
  head(-2)
```

```{r, fig.width = 8}
combined_one <-  combined_indices %>% 
  subset(select = -c(ind_close, pm_close)) %>% 
  gather(index, values, precious_metals:industrial_metals)
  
ggplot(combined_one) + 
  geom_line(aes(x=date, y=values, color = index)) + 
  labs(title = "Plot of S&P GSCI Precious Metals and Industrial Metals Indices",
    y = "Price, (1 = 1/1/1990)",
    x= "Date",
    caption = "GFD, S&P Indices as of 13 October 2020") +
  scale_x_date(date_breaks = "12 months", date_labels =  "%Y") +
  theme_minimal() +
  theme(axis.text.x=element_text(angle=60, hjust=1)) +
  scale_color_brewer(palette = "Viridis") +
  scale_color_discrete(name = "Series", labels= c("Precious Metals", "Industrial Metals"))
```


# Introduction

The idea for this group project was to come up with a strategy that either exploited an arbitrage opportunity in the market, or represents another form of hedge fund strategy. Our group decided to focus on using technical indicators. Within this area, we specifically chose moving averages, and as a suitable market for their application settled on metal commodities.

# Economic Rationale

# Data
## Papers
- [S&P GSCI Precious Metals Index](https://www.spglobal.com/spdji/en/indices/commodities/sp-gsci-precious-metals/#overview)
- [S&P GSCI Industrial Metals Index](https://www.spglobal.com/spdji/en/indices/commodities/sp-gsci-industrial-metals/#overview)

# Method Used

## Portfolio Allocation

In order to ideally work within the metals markets, the portfolio will consist ocmpletely of two already existing indices that are calculated on a daily basis, the S&P Precious Metals Index, consisting of [TBC] and the S&P Industrial Metals, containing [TBC]. By using these two indices as our baseline instead of attempting to construct our own, we can create a two-security portfolio with different weights to find the best possible results. As for the choice of allocations, we tried different combination weights of the indices. 

To construct the efficient portfolio, we had to calculate the return and variance of the two separate indices.

```{r}

# Return - Variance Calculation for the Separate Metals Indices

ind_price <- na.approx(zoo(combined_indices$ind_close, combined_indices$date))
prec_price <- na.approx(zoo(combined_indices$pm_close, combined_indices$date))

rets_industry <- Return.calculate(xts(ind_price),  method = "discrete")
names(rets_industry) <- "return_ind"

rets_prec <- Return.calculate(xts(prec_price),  method = "discrete")
names(rets_prec) <- "return_prec"

combined_indices <- cbind(combined_indices, rets_industry, rets_prec)

stats_individual <- combined_indices %>% 
  summarise(mean_ind = mean(return_ind[-1]), mean_prec = mean(return_prec[-1]),
            sd_ind = sd(return_ind[-1]), sd_prec = sd(return_prec[-1]))

```

```{r}
# Weighted Portfolio Function - Work in Progress
w_portfolio <- function(dataset, 
                        w_1, 
                        index_1, 
                        index_2){
  library(tidyverse)
  w_2 <- 1 - w_1
  portfolio <- dataset %>% 
  mutate(index = (w_1 * dataset$index_1 + w_2 * dataset$index_2))
}

# I don't understand why this does not work...
equal <- w_portfolio(
  combined_indices, 
  0.5, 
  precious_metals, 
  industrial_metals)
# Like, I know the error is one that I am making. Still, the code above looks valid, and I would just like it to run.
# Pease I just wanted a cool function...
```

```{r}
# Efficient Portfolio

# Statistics for the Portfolio: Mean, StDev, Correlation
calc_efficient <- combined_indices %>% 
  summarise(mean_ind = mean(return_ind[-1]), mean_prec = mean(return_prec[-1]),
            sd_ind = sd(return_ind[-1]), sd_prec = sd(return_prec[-1]),
            corr_ind = cor(return_ind[-1],return_prec[-1]))

# Function to calculate the Weighting of Industrial Metals in the Final Portfolio
sh_r_max <- function(x){
  (x*calc_efficient$mean_ind+(1-x)*calc_efficient$mean_prec)/sqrt(x^2*calc_efficient$sd_ind^2+(1-x)^2*calc_efficient$sd_prec^2+2*x*(1-x)*calc_efficient$sd_ind*calc_efficient$sd_prec*calc_efficient$corr_ind)
}

# Calculating optimal weights for industrial index
opt_port <- optimize(f = sh_r_max, lower = -1,upper = 1, maximum = TRUE)

# assigning weights to the two indices
weight_industrial <- opt_port$objective
weight_precious <- 1-weight_industrial

# creating (theoretically) efficient combination
efficient_portfolio <- combined_indices %>% 
  mutate(efficient = weight_industrial * industrial_metals + weight_precious * precious_metals) %>% 
  subset(select = c(date, efficient))
```

```{r}
# 50/50 Portfolio
# Weights
eq_w_pm <- 0.5
eq_w_ind <- 1-eq_w_pm

# calculate index
eq_w_ind <- combined_indices %>% 
  mutate(eq_weight = eq_w_pm * precious_metals + eq_w_ind * industrial_metals) %>% 
  subset(select = c(date, eq_weight))
```

```{r}
# Joining the Portfolios
# Add Equal Weights to Individual Indices
indices_equal <- right_join(eq_w_ind, combined_indices, by = "date") %>% 
 subset(select = -c(ind_close, pm_close )) %>% 
  subset(select = -c(return_ind, return_prec))

# Add Efficient Portfolio
portfolios <- left_join(indices_equal, efficient_portfolio, by = "date")
```

```{r}
# Ask Stas what this does
equal_price <- na.approx(zoo(portfolios$eq_weight, portfolios$date))
rets_eq <- Return.calculate(xts(equal_price),  method = "discrete")
names(rets_eq) <- "return_eq"

efficient_price <- na.approx(zoo(portfolios$efficient, portfolios$date))
rets_eff <- Return.calculate(xts(efficient_price),  method = "discrete")
names(rets_eff) <- "return_eff"

# Statistics for the Equal Weight Portfolio
portfolios <- cbind(portfolios, rets_eq)
stats_eq <- portfolios %>% 
  summarise(mean_eq = mean(return_eq[-1]),
            sd_eq = sd(return_eq[-1]))

# Statistics for the Efficient Portfolio
portfolios <- cbind(portfolios, rets_eff)
stats_eff <- portfolios %>% 
  summarise(mean_eff = mean(return_eff[-1]),
            sd_eff = sd(return_eff[-1]))
```


```{r}
# Sharpe Ratios

# Assumed Risk Free Rate, based on current 10-Year US Treasuries 
risk_free <- 0.0076

# Sharpe Ratio Function ????????
sharpe <- function(dataset, mean, sd){
  (dataset$mean - (risk_free / 365)) / dataset$sd
}

# Sharpe Ratios for the Individual Indices
sharpe_ind <- sharpe(stats_individual, mean_ind, sd_ind)
sharpe_prec <- sharpe(dataset = stats_individual, mean = mean_prec, sd = sd_prec)
# FOR SOME F***ING REASON THE FORMULA ABOVE DOES NOT WORK FOR THE INDIVIDUAL SHARPE RATIOS. I COULD THROW MY LAPTOP AGAINST A WALL
sharpe_efficient <- sharpe(stats_eff, mean_eff, sd_eff)
sharpe_equal <-sharpe(stats_eq, mean_eq, sd_eq)
# But it does work for these two clowns...

sharpe_ind <- (stats_individual$mean_ind - risk_free / 365)/stats_individual$sd_ind
sharpe_prec <- (stats_individual$mean_prec - (risk_free / 365)) / stats_individual$sd_prec

```



```{r}
# combining the four portfolios into one
portfolios_overview <- left_join(indices_equal, efficient_portfolio, by = "date") %>% 
  gather(index, values, eq_weight:efficient)
```

### Portfolio Statistics 

```{r, fig.width = 11, echo=FALSE}
# Combination Graph
ggplot() + 
  geom_line(data = portfolios_overview, aes(x=date, y=values, color = index)) + 
  labs(title = "Price Development of the Different Combinations of Metals Indices",
       caption = "Source: Finaeon, S&P as of October 2020",
       x = "Date",
       y="Index (1 = 1/1/1990)") +
  scale_color_brewer(palette = "Viridis") + 
  scale_color_discrete(name = "Series", labels = c("Efficient Portfolio", "Equal Weights", "Industrial Metals", "Precious Metals")) +
  scale_x_date(date_breaks = "12 months", date_labels =  "%Y") +
  theme_minimal() +
  theme(axis.text.x=element_text(angle=60, hjust=1))
```

The graph shows clearly that the most efficient portfolio is one in which the heaviest weighting is placed on the precious metals component of the portfolio, which is not surprising given it's outperformance of the industrial metals class, especially over the last ten years. For a further analysis, this raises the obvious question of whether a more efficient portfolio could be constructed using different indices/components that would diversify the returns away from this sector. 


## Technical Indicator

From https://uc-r.github.io/ts_moving_averages

The concept of simple moving averages can be extended to taking moving averages of moving averages. This technique is often employed with an even number of data points so that the final product is symmetric around each point. 
An even-numbered moving average is unbalanced, and for our purposes, the unbalancing will be in favor of more recent observations. For example, to calculate a 4-MA, the equation is as follows:
^yt=(yt−1+yt+yt+1+yt+2)/4

To make the moving average symmetric (and therefore more accurate), we then take a 2-MA of the 4-MA to create a 2 x 4-MA. For the 2-MA step, we average the current and previous moving averages, thus resulting in an overall estimate of:



### Finding appropriate Modifiers for the TMA

The main challenge lies in finding the appropriate time periods for the TMA. As it is an average of averages, we have to consider which of these will give us the best return. 
The best TMA will be one that fits the trend well enough, but can still react to changes in the underlying assets quickly enough to be useful.

To compute a basic TMA, we can use the ma() function and take a look at the output, in this case with a 60 day compound.
```{r, fig.width = 10}
# rolling averages. Useful for later calculations
# k = number of days used in average

portfolios_tma <- portfolios_overview %>% 
  mutate(ma4 = ma(values, order = 60, centre = TRUE))

pf_subset <- portfolios_tma %>% 
  #filter(index == "eq_weight" || index == "efficient")
  filter(index %in% c("eq_weight", "efficient"))

# Have to find a way to remove the extreme values at the beginning and end of the series

# 60 Day TMAs over the daily data for the two composite portfolios
ggplot(pf_subset) +
  geom_line(aes(x = date, y=values, group = index), 
            alpha = 0.8, fill = "black", size = 0.2) +
  geom_line(aes(x = date, y=ma4, color = index)) + 
  scale_color_brewer(palette="Dark2", name = "Series", labels = c("Efficient Portfolio", "Equal Weights")) +
  scale_x_date(date_breaks = "12 months", date_labels =  "%Y") +
  theme_minimal() +
  theme(axis.text.x=element_text(angle=60, hjust=1))

```

In order to see the efficiency of any portfolio, we have to implement buy and sell signals. In our case, as described earlier, the idea would be to buy when the TMA is passed upwards, and to sell & short when the line crosses below. 

```{r}
# In order to find the trade points, we have to know the dates where the line is crossed 
```


This would give us a return of [TBA]

Using the optimize function we employed to get the portfolio weights earlier, we can attempt to maximise the output of our TMA line on both portfolios. 

## Market Choice
```{r, fig.width = 5}
combined_indices %>% 
  subset(select = c(precious_metals, industrial_metals)) %>% 
  ggpairs(combined_indices)
```

As the above corelation graph shows, and intuition would confirm, there is an extreme correlation between the different classes of metals. This is despite hte fact that gold, which makes up a large part of the precious metals index, is traded less for its value sas a metal from an utilitarian perspective and more because of it's economic value as a criiss/hedging asset. 

# Results / Main Findings

# Appendix
```{r}
# FUNCTIONS



```

## Importing and Filtering Equities Indices for Comparison Purposes
```{r}
# Importing Index Data
# Filtering: Dates, Unused Indices (keeping )
global_equities_indices <- read.csv("data/global.csv", skip = 51)

gei_filtered <- global_equities_indices %>%
  mutate(date = as.Date(global_equities_indices$Date, format = "%Y/%m/%d")) %>% 
  filter(date > as.Date("1989-12-31")) %>% 
  subset(data = global_equities_indices, select = c(Date, X_NDXD_Close, X_DJA3D_Close, X_GDAXIPD_Close, X_SPXD_Close))
```
